---
title: "Ejercicios Tema 2"
format: html
editor: visual
---

# Ejercicio 1.

Sea (ğ‘‹,ğ‘Œ) es un vector aleatorio con distribuciÃ³n uniforme en el cuadrado \[âˆ’1,1\]Ã—\[âˆ’1,1\] de Ã¡rea 4.

## 1. Aproximar mediante simulaciÃ³n ğ‘ƒ(ğ‘‹+ğ‘Œ â‰¤ 0) y compararla con la probabilidad teÃ³rica (obtenida aplicando la regla de Laplace Ã¡rea favorable Ã¡rea posible ).

```{r}
##correccion
#a
n<-100000
x<- runif(n,-1,1)
y<- runif(n,-1,1)

prob_sim <- mean(x+y<=0)
prob_sim

prob_teorica<- 2/4
prob_teorica


#b

prob_pi<- 4*mean( x^2 + y^2<=1)
prob_pi


```

```{r}
set.seed(123)

n<- 10000 #numero de puntos a lanzar

x<-runif(n,-1,1)
y<-runif(n,-1,1)

cumplen <- x+y<=0
table(cumplen)
prob_simulada<- mean(cumplen)
prob_simulada

#calculamos el area teorica ( area favorable/area posible)
#el area posible es 4 
#el area faborable es 2
prob_teorica<- 2/4
prob_teorica

```

## 2. Aproximar el valor de ğœ‹ mediante simulaciÃ³n a partir de ğ‘ƒ(ğ‘‹2 +ğ‘Œ2 â‰¤ 1).

```{r}
#Dentro del cuadrado, hay un cÃ­rculo de radio 1. Si contamos cuÃ¡ntos puntos caen #dentro del cÃ­rculo, podemos usar eso para estimar Ï€.

dentro_circulo <- x^2 + y^2 <= 1
prob_circulo <- mean(dentro_circulo)

#Como el Ã¡rea del cuadrado es 4, multiplicamos por 4 para estimar Ï€
pi_aproximado <- 4 * prob_circulo
pi_aproximado

```

# Ejercicio 2.

Consideramos el experimento de Bernoulli consistente en el lanzamiento de una moneda.

## 1. Empleando la funciÃ³n sample, obtener 1000 simulaciones del lanzamiento de una moneda (0 = cruz, 1 = cara), suponiendo que no estÃ¡ trucada. Aproximar la probabilidad de cara a partir de las simulaciones.

```{r}

#n<- 1000
monedas <- sample(c(0,1),size=1000,replace=TRUE)
#si quisieramos cambiar la sprobabilidades:
#monedas <- sample(c(0,1),size=1000,replace=TRUE, prob = c(0.1,0.2) )
#contamos las veces que sale cara y lo dividimos por el total

#table(monedas)/length(monedas)
prob_cara <- mean(lanzamientos)
prob_cara

```

## 2. En R pueden generarse valores de la distribuciÃ³n de Bernoulli mediante la funciÃ³n rbinom(nsim, size=1, prob). Generar un grÃ¡fico de lineas considerando en el eje ğ‘‹

el nÃºmero de lanzamientos (de 1 a 10000) y en el eje ğ‘Œ la frecuencia relativa del suceso cara (puede ser recomendable emplear la funciÃ³n cumsum)

```{r}
n<-10000
##lanzamientos<-rbinom(n,size = 1, prob = 0.5)
##lanzamientos

seq_n<- 1:1000
prob<- numeric(length =length(seq_n))
for(i in 1:1000) {
  lanzamientos <-sample(c(1,0),seq_n[i], replace=TRUE)
  prob[i] <- mean(lanzamientos)
}

plot(seq_n,prob,type='l')

library(ggplot2)

##f_relativa<- cumsum(lanzamientos) /1:n 


##plot(lanzamientos,f_relativa)
```

# Ejercicio 3.

En 1651, el Caballero de MÃ©rÃ© le planteÃ³ a Pascal una pregunta relacionada con las apuestas y los juegos de azar: Â¿es ventajoso apostar a que en cuatro lanzamientos de un dado se obtiene al menos un seis? Este problema generÃ³ una fructÃ­fera correspondencia entre Pascal y Fermat que se considera, simbÃ³licamente, como el nacimiento del CÃ¡lculo de Probabilidades.

## 1. Escribir una funciÃ³n que simule el lanzamiento de ğ‘› dados. El parÃ¡metro de entrada es

el nÃºmero de lanzamientos ğ‘›, que toma el valor 4 por defecto, y la salida debe ser TRUE si se obtiene al menos un 6 y FALSE en caso contrario.

```{r}
#CORRECCION
replicas<- 1:1000
iteracion_experimento<- numeric(length =length(replicas))
for(i in 1:1000) {
  lanzamientos <-sample(1:6,4, replace=TRUE)
  iteracion_experimento[i] <- any(lanzamientos==6)
}
mean(iteracion_experimento)
```

```{r}

simular_lanzamiento<- function(n=4) {
  dados <- sample(1:6,size=n,replace=TRUE)
  return(any(dados==6))
}
```

## 2. Utilizar la funciÃ³n anterior para simular \$ nsim= 10000 \$ jugadas de este juego y calcular

la proporciÃ³n de veces que se gana la apuesta (obtener al menos un 6 en ğ‘› lanzamientos), usando ğ‘› = 4. Comparar el resultado con la probabilidad teÃ³rica 1 âˆ’ (5/6)ğ‘›.

```{r}
#correccion

results<- mean(replicate(1000, any(sample(1:6,4,replace=TRUE)==6)))
results
```

```{r}

nsim <- 10000

results<- replicate(nsim, simular_lanzamiento())

table(results)/length(results)
prob_simulada<-
prob_simulada
prob_teorica<- 1 - (5/6)^4
prob_teorica
```

# Ejercicio 4.

Partiendo de la generaciÃ³n de nÃºmeros aleatorios uniformes en el intervalo \[0,1\], simule por el mÃ©todo de la transformada inversa las siguientes distribuciones:

## 1. DistribuciÃ³n Uniforme: ğ‘‹ âˆ¼ ğ‘ˆ\[ğ‘,ğ‘\] sabiendo que ğ‘“ğ‘‹ = 1/(ğ‘ âˆ’ ğ‘) y que ğ¹ğ‘‹ = âˆ«ğ‘¥ğ‘ğ‘“ğ‘‹ğ‘‘ğ‘¥. Compare el resultado con lo obtenido con la funciÃ³n runif.

```{r}

#tenemos la f, sacamos la F:
#F= (x-a)/(b-a)
#y= (x-a)/(b-a)
# x = (b-a)*y+a
#y=U~U(0,1)

a<-10
b<-100
n<-10000
U<- runif(n)
unif_ab <- (b-a)*U+a

hist(unif_ab)

```

## 2.DistribuciÃ³n Weibull: ğ‘‹ âˆ¼ ğ‘Šğ‘’ğ‘–ğ‘ğ‘¢ğ‘™ğ‘™(ğœ†,ğ›¼) sabiendo que ğ¹ğ‘‹(ğ‘¥) = 1 âˆ’ ğ‘’âˆ’(ğœ†ğ‘¥)ğ›¼. Compare el resultado con lo obtenido con la funciÃ³n rweibull.

```{r}
#calculamos la inversa:
#y = 1 - e^-((lambx)^alfa)
#ln(1-y) = lamb*x ^ alfa
#x = (ln(1-y)^1/alfa)*lamba

lamba<-10
alfa<-2
n<-10000
U<- runif(n)

weibull<- (-log(1-U))^(1/alfa)*lamba

hist(weibull)


```

## 3.DistribuciÃ³n Pareto: ğ‘‹ âˆ¼ ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘¡ğ‘œ(ğ‘,ğ‘) sabiendo que ğ¹ğ‘‹(ğ‘¥) = 1âˆ’(ğ‘/ğ‘¥)ğ‘.

```{r}

#F=1- (b/x)*a
#b/(y+1)/a = x
n<-1000
a<-10
b<-5
U<-runif(n)
pareto<- (b/(U+1)*a) 
hist(pareto)


```

RESUMEN Y QUE PUEDE CAER

T1:

-ANALISIS DESC -DATOS-\>HAZ ANALISIS DE DATOS

-68

-BOXPLOT

-DIAPOSITIVA 70 (DATA FRAME CON VARIABLE A AGRUPAR)

T2:

-EJERS LIKE

-NORMAL BIVARIADA SIMULAR DATOS SEGUN MATRIZ DE COVARIANZA
